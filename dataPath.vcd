$date
	Wed Feb  7 11:03:42 2024
$end
$version
	Icarus Verilog
$end
$timescale
	10ns
$end
$scope module dataPath_tb $end
$var wire 7 ! opecode [6:0] $end
$var wire 1 " zero $end
$var wire 32 # writeData [31:0] $end
$var wire 16 $ pc [15:0] $end
$var wire 1 % f7 $end
$var wire 3 & f3 [2:0] $end
$var wire 32 ' ALUResult [31:0] $end
$var reg 3 ( ALUControl [2:0] $end
$var reg 1 ) ALUSrc $end
$var reg 1 * branch $end
$var reg 1 + clk $end
$var reg 2 , inmSrc [1:0] $end
$var reg 32 - instr [31:0] $end
$var reg 1 . jump $end
$var reg 32 / readData [31:0] $end
$var reg 1 0 regWrite $end
$var reg 2 1 resultSrc [1:0] $end
$scope module uut $end
$var wire 3 2 ALUControl [2:0] $end
$var wire 32 3 ALUResult [31:0] $end
$var wire 1 ) ALUSrc $end
$var wire 1 * branch $end
$var wire 1 + clk $end
$var wire 2 4 inmSrc [1:0] $end
$var wire 32 5 instr [31:0] $end
$var wire 1 . jump $end
$var wire 7 6 opecode [6:0] $end
$var wire 16 7 pc [15:0] $end
$var wire 32 8 readData [31:0] $end
$var wire 1 0 regWrite $end
$var wire 2 9 resultSrc [1:0] $end
$var wire 32 : writeData [31:0] $end
$var wire 1 " zero $end
$var wire 32 ; s_srcB [31:0] $end
$var wire 32 < s_srcA [31:0] $end
$var wire 32 = s_src2 [31:0] $end
$var wire 32 > s_result [31:0] $end
$var wire 16 ? s_pcPlus [15:0] $end
$var wire 16 @ s_pcNext [15:0] $end
$var wire 16 A s_pcJump [15:0] $end
$var wire 16 B s_pc [15:0] $end
$var wire 16 C s_PCK1 [15:0] $end
$var wire 32 D s_InmExt [31:0] $end
$var wire 32 E s_ALUResult [31:0] $end
$var wire 1 F op $end
$var wire 1 % f7 $end
$var wire 3 G f3 [2:0] $end
$var reg 16 H cuatro [15:0] $end
$scope module addPC4 $end
$var wire 16 I res [15:0] $end
$var wire 16 J op2 [15:0] $end
$var wire 16 K op1 [15:0] $end
$upscope $end
$scope module addPCJump $end
$var wire 16 L op1 [15:0] $end
$var wire 16 M res [15:0] $end
$var wire 16 N op2 [15:0] $end
$upscope $end
$scope module alu $end
$var wire 3 O ALUControl [2:0] $end
$var wire 32 P res [31:0] $end
$var wire 1 " zero $end
$var wire 32 Q srcB [31:0] $end
$var wire 32 R srcA [31:0] $end
$var reg 32 S aux [31:0] $end
$var reg 1 T aux_zero $end
$upscope $end
$scope module bancoDeRegistros $end
$var wire 5 U a1 [4:0] $end
$var wire 5 V a2 [4:0] $end
$var wire 5 W a3 [4:0] $end
$var wire 1 + clk $end
$var wire 32 X rd1 [31:0] $end
$var wire 32 Y rd2 [31:0] $end
$var wire 1 0 we $end
$var wire 32 Z wd3 [31:0] $end
$var integer 32 [ i [31:0] $end
$upscope $end
$scope module extensionDeSigno $end
$var wire 32 \ instr [31:0] $end
$var wire 2 ] src [1:0] $end
$var wire 32 ^ immExt [31:0] $end
$var reg 32 _ immaux [31:0] $end
$upscope $end
$scope module muxJump $end
$var wire 16 ` e1 [15:0] $end
$var wire 16 a e2 [15:0] $end
$var wire 16 b sal [15:0] $end
$var wire 1 . sel $end
$var reg 16 c aux [15:0] $end
$upscope $end
$scope module muxPcNext $end
$var wire 16 d e1 [15:0] $end
$var wire 16 e e2 [15:0] $end
$var wire 16 f sal [15:0] $end
$var wire 1 * sel $end
$var reg 16 g aux [15:0] $end
$upscope $end
$scope module muxResult $end
$var wire 32 h e1 [31:0] $end
$var wire 32 i e2 [31:0] $end
$var wire 32 j e3 [31:0] $end
$var wire 32 k e4 [31:0] $end
$var wire 32 l sal [31:0] $end
$var wire 2 m sel [1:0] $end
$var reg 32 n aux [31:0] $end
$upscope $end
$scope module muxSrcB $end
$var wire 32 o e1 [31:0] $end
$var wire 32 p e2 [31:0] $end
$var wire 32 q sal [31:0] $end
$var wire 1 ) sel $end
$var reg 32 r aux [31:0] $end
$upscope $end
$scope module pcReg $end
$var wire 1 + clk $end
$var wire 16 s pcNext [15:0] $end
$var wire 16 t pc [15:0] $end
$var reg 16 u s_pc [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 u
b0 t
b100 s
b1 r
b1 q
b1 p
b0 o
b1 n
b0 m
b1 l
b100 k
b1 j
bx i
b1 h
b100 g
b100 f
b1 e
b100 d
b100 c
b100 b
b1 a
b100 `
b1 _
b1 ^
b0 ]
b100001000000100000000 \
b100000 [
b1 Z
b0 Y
b0 X
b10 W
b1 V
b1 U
0T
b1 S
b0 R
b1 Q
b1 P
b0 O
b0 N
b1 M
b1 L
b100 K
b0 J
b100 I
b100 H
b0 G
0F
b1 E
b1 D
b100 C
b0 B
b1 A
b100 @
b100 ?
b1 >
b0 =
b0 <
b1 ;
b0 :
b0 9
bx 8
b0 7
bz 6
b100001000000100000000 5
b0 4
b1 3
b0 2
b0 1
10
bx /
0.
b100001000000100000000 -
b0 ,
0+
0*
1)
b0 (
b1 '
b0 &
0%
b0 $
b0 #
0"
bz !
$end
#50
b1000 C
b1000 b
b1000 s
b1000 c
b101 A
b101 M
b101 a
b1000 k
b1000 @
b1000 I
b1000 `
b100 $
b100 7
b100 B
b100 J
b100 N
b100 t
b100 u
1+
#100
0+
#150
b1100 C
b1100 b
b1100 s
b1100 c
b1001 A
b1001 M
b1001 a
b1100 k
b1100 @
b1100 I
b1100 `
b1000 $
b1000 7
b1000 B
b1000 J
b1000 N
b1000 t
b1000 u
1+
#200
0+
